# LogScope Development Instructions

**⚠️ Important:** Always update this file when progressing to new phases or changing architecture decisions.

## Project Overview

**LogScope** is a self-hosted structured log collection and query service for web applications. Users clone the repository, run the service locally on their own device, and use it for development and debugging. It aggregates log events from both backend (Node/Express) and frontend (browser) environments into a unified queryable store.

**Purpose:** Enable developers to detect errors, explore root causes, recognize patterns, and analyze event sequences through correlated structured logging in a local, self-contained environment.

## Current Status

**Phase 8: Quick Start Scripts & Polish** ✅ COMPLETE
- Automated configuration scripts (configure.sh, configure.bat)
- Comprehensive README.md with feature overview
- Port configuration helpers for easy setup
- Windows and Linux/macOS support

**Phase 7: Documentation & Configuration** ✅ COMPLETE
- OpenAPI/Swagger specification (openapi.yaml)
- Getting started guide (GETTING_STARTED.md)
- Environment configuration documentation (ENVIRONMENT.md)
- Deployment guide (DEPLOYMENT.md)

**Branch:** `main`

**Completed Features:**
- ✅ Phase 8: Quick Start Scripts & Polish
- ✅ Phase 7: Documentation & Configuration
- ✅ Phase 6: Error Handling & Validation (input validation, rate limiting, retry logic)
- ✅ Phase 5: Frontend Log Viewer (complete React UI with critical alerts)
- ✅ Phase 4: Real-Time Streaming (WebSocket)
- ✅ Phase 3: Query & Filtering API
- ✅ Phase 2: Log Collection & Persistence
- ✅ Phase 1: Infrastructure & Data Model

## Project Goals (7 Phases)

1. ✅ **Phase 1:** Infrastructure & Data Model
2. ✅ **Phase 2:** Log Collection & Persistence (POST /api/logs/collect, file storage)
3. ✅ **Phase 3:** Query & Filtering API (GET /api/logs/search with time/level/subject filters)
4. ✅ **Phase 4:** Real-Time Streaming (WebSocket endpoint /ws)
5. ✅ **Phase 5:** Frontend Log Viewer (full UI components with critical alerts)
6. ✅ **Phase 6:** Error Handling & Validation (rate limiting, input validation)
7. ✅ **Phase 7:** Documentation & Configuration (API docs, getting started, deployment)

## Key Data Models

### LogEntry
```typescript
{
  eventId: string;              // UUID, auto-generated by server
  timestamp: string;            // ISO 8601 UTC
  level: "debug" | "info" | "warn" | "error" | "success";
  subject: string;              // categorical label
  content: string | object;     // flexible JSON
  source: {
    function: string;           // function name where log originated
    file: string;              // filename
    process: string;           // process ID or name
    runtime: "node" | "browser";
    serviceName: string;
  };
  correlation: {
    requestId?: string;        // request trace ID
    sessionId?: string;        // session ID
    userId?: string;           // user ID (optional)
  };
}
```

### API Response Contract
```typescript
// Success
{ success: true, data: T, total?: number, limit?: number, offset?: number }

// Error
{ success: false, error: string, errorCode: string }
```

## Key Architectural Decisions

- **Data Format:** LogEntry with ISO 8601 timestamps, "success" level included
- **Storage:** File-based (logs/backend.json, logs/frontend.json as JSON arrays)
- **Index:** In-memory query index built on startup
- **Network:** Services bound to 127.0.0.1 with WSL2 localhost forwarding
- **UI Framework:** Bootstrap 5 with TypeScript
- **Type Safety:** Strict TypeScript, shared types between frontend/backend

## Core Data Models

**LogEntry:**
```typescript
{
  eventId: string;          // UUID, auto-generated by server
  timestamp: string;        // ISO 8601 UTC
  level: "debug" | "info" | "warn" | "error" | "success";
  subject: string;          // categorical label
  content: string | object; // flexible JSON
  source: {
    function: string;
    file: string;
    process: string;
    runtime: "node" | "browser";
    serviceName: string;
  };
  correlation: {
    requestId?: string;
    sessionId?: string;
    userId?: string;
  };
}
```

**API Response:**
```typescript
// Success: { success: true, data: T, total?: number, limit?: number, offset?: number }
// Error: { success: false, error: string, errorCode: string }
```

## Development Workflow

### Starting Services
```bash
# Terminal 1: Backend
cd server && npm run dev

# Terminal 2: Frontend
cd web && npm run dev
```

### Project Structure
```
server/                  # Express backend
  src/types/            # Data models
  src/storage/          # File I/O and query index
  src/api/              # Routes and middleware
  
web/                    # React frontend
  src/types/            # Type definitions
  src/api/              # API client
  src/components/       # React components
```

## Code Conventions

- Use `import type` for type-only imports
- Types in `src/types/`, business logic in feature folders
- Interfaces prefixed with `I` (e.g., `IFileStorage`)
- Components in `components/` with `.tsx` extension
- Log content is **untrusted input** - validate safely, never execute
- Bootstrap utility classes for styling (flex, spacing, colors)

## Important Constraints

- No authentication in v1 (trusted environment)
- No log redaction in v1 (future enhancement)
- Designed for AI agent analysis, not human dashboards
- Bounded query scope via time ranges and result limits







## Restarting Services with File Watching Enabled for Development
- No need to restart frontend and backend unless a build is required; they are always running in the background with file watching enabled.
- For backend, it is using nodemon with polling enabled, so it will automatically restart when files change.
- For frontend, Vite's dev server is configured with polling, so it will also automatically reload when files change.
